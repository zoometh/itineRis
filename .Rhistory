read_mines <- function(d = NA,
df.path = paste0(system.file(package = "itineRis"),
"/extdata/Coordinates-mines_Thomas Huet.xlsx"),
df.sheetnames = c("all"),
extract.mines = TRUE,
pattern.mines.name = "locality",
pattern.mines.coords = c("longitude", "latitude")){
l.keys <- c()
if("all" %in% df.sheetnames){
for(sheetname in openxlsx::getSheetNames(df.path)){
l.keys <- c(l.keys, sheetname)
data.sheetname <- openxlsx::read.xlsx(df.path,
sheet = sheetname)
d[[sheetname]] <- data.sheetname
}
} else {
for(sheetname in df.sheetnames){
data.sheetname <- openxlsx::read.xlsx(df.path,
sheet = df.sheetnames)
d[[sheetname]] <- df.sheetnames
}
l.keys <- df.sheetnames
}
if(extract.mines){
df.coords <- data.frame(site = character(),
x = numeric(),
y = numeric())
for(sheetname in l.keys){
# sheetname <- "Iberian Peninsula"
# sheetname <- "France"
# sheetname <- "Switzerland"
col.names <- colnames(d[[sheetname]])
long.lat.idx <- c()
# find the name of the mine
name.idx <- grep(toupper(pattern.mines.name), toupper(col.names))
# find the X,Y columns
for(coords.columns in pattern.mines.coords){
# coords.columns <- "longitude"
long.lat.idx <- c(long.lat.idx, grep(toupper(coords.columns), toupper(col.names)))
}
df.coord.sheet <- data.frame(site = d[[sheetname]][name.idx],
x = d[[sheetname]][long.lat.idx[1]],
y = d[[sheetname]][long.lat.idx[2]])
names(df.coord.sheet) <- c("site", "x", "y")
# cleaning
df.coord.sheet <- df.coord.sheet[!is.na(as.numeric(df.coord.sheet$x)), ]
df.coord.sheet <- df.coord.sheet[!is.na(as.numeric(df.coord.sheet$y)), ]
# df.coord.sheet <- df.coord.sheet[,as.numeric(as.character(df.coord.sheet$y))]
df.coord.sheet <- na.omit(df.coord.sheet)
df.coord.sheet <- df.coord.sheet[!duplicated(df.coord.sheet), ]
df.coords <- rbind(df.coords, df.coord.sheet)
}
d[["mines.coords"]] <- df.coords
}
}
d <- hash::hash()
df.mines <- read_mines(d = d,
df.path = "C:/Rprojects/itineRis/results/Coordinates-mines_Thomas Huet.xlsx")
#' Read the dataset of mines
#' @name read_mines
#' @description Read the dataset of mines. Will store every spreadsheet under its name within the hash object (e.g. "France")
#'
#' @param d a hash dictionnary-like object to store the data
#' @param df.path the path and name of the dataset. An XLSX file.
#' @param df.sheetnames the name or index of the spreadsheet(s) to be read. By default "all" will read all the spreadsheets
#' @param extract.mines if TRUE, will extract the coordinates of one to many spreadsheets and store them under the "mines.coords" key
#' @param pattern.mines.coords if `extract.mines` is TRUE, will search (regex) for these patterns. A vector of two strings: first longitude/X, second: Y/latitude. By default `c("longitude", "latitude")`
#'
#' @return A hash
#'
#' @examples
#'
#' d <- hash::hash()
#' df.mines <- read_mines(d = d,
#'                        df.path = "C:/Rprojects/itineRis/results/Coordinates-mines_Thomas Huet.xlsx")
#'
#' @export
read_mines <- function(d = NA,
df.path = paste0(system.file(package = "itineRis"),
"/extdata/Coordinates-mines_Thomas Huet.xlsx"),
df.sheetnames = c("all"),
extract.mines = TRUE,
pattern.mines.name = "locality",
pattern.mines.coords = c("longitude", "latitude")){
l.keys <- c()
if("all" %in% df.sheetnames){
for(sheetname in openxlsx::getSheetNames(df.path)){
l.keys <- c(l.keys, sheetname)
data.sheetname <- openxlsx::read.xlsx(df.path,
sheet = sheetname)
d[[sheetname]] <- data.sheetname
}
} else {
for(sheetname in df.sheetnames){
data.sheetname <- openxlsx::read.xlsx(df.path,
sheet = df.sheetnames)
d[[sheetname]] <- df.sheetnames
}
l.keys <- df.sheetnames
}
if(extract.mines){
df.coords <- data.frame(site = character(),
x = numeric(),
y = numeric())
for(sheetname in l.keys){
# sheetname <- "Iberian Peninsula"
# sheetname <- "France"
# sheetname <- "Switzerland"
col.names <- colnames(d[[sheetname]])
long.lat.idx <- c()
# find the name of the mine
name.idx <- grep(toupper(pattern.mines.name), toupper(col.names))
# find the X,Y columns
for(coords.columns in pattern.mines.coords){
# coords.columns <- "longitude"
long.lat.idx <- c(long.lat.idx, grep(toupper(coords.columns), toupper(col.names)))
}
df.coord.sheet <- data.frame(site = d[[sheetname]][name.idx],
x = d[[sheetname]][long.lat.idx[1]],
y = d[[sheetname]][long.lat.idx[2]])
names(df.coord.sheet) <- c("site", "x", "y")
# cleaning
df.coord.sheet <- df.coord.sheet[!is.na(as.numeric(df.coord.sheet$x)), ]
df.coord.sheet <- df.coord.sheet[!is.na(as.numeric(df.coord.sheet$y)), ]
# df.coord.sheet <- df.coord.sheet[,as.numeric(as.character(df.coord.sheet$y))]
df.coord.sheet <- na.omit(df.coord.sheet)
df.coord.sheet <- df.coord.sheet[!duplicated(df.coord.sheet), ]
df.coords <- rbind(df.coords, df.coord.sheet)
}
d[["mines.coords"]] <- df.coords
}
return(d)
}
d <- hash::hash()
d <- read_mines(d = d,
df.path = "C:/Rprojects/itineRis/results/Coordinates-mines_Thomas Huet.xlsx")
d$mines.coords$x
#' Create an HTML interactive map for the site distribution
#' @name map_leaflet
#' @description
#'
#' @param d a hash dictionnary-like object to store the data. By default NA
#' @param df.path the path to the dataframe. This dataframe must have at least three columns: one for the site name (by defaut 'site'), two for the coordinates (by default, 'x' and 'y'). By default NA, then will read the `d` variable
#' @param export.plot if TRUE, export the map
#' @param out.plot the name of the output map
#' @param dirOut path of the output directory
#'
#'
#' @return a leaflet interactive map
#'
#' @examples
#'
#' d <- hash::hash()
#' d <- read_mines(d = d,
#'                 df.path = "C:/Rprojects/itineRis/results/Coordinates-mines_Thomas Huet.xlsx")
#' map_leaflet(d = d, d.coords = "mines.coords")
#'
#'
#' map_leaflet(df.path = paste0(system.file(package = "itineRis"), "/extdata/sites_coords.tsv"),
#'             color.point = "blue")
#'
#' @export
map_leaflet <- function(d = NA,
d.coords = NA,
df.path = paste0(system.file(package = "itineRis"), "/extdata/sites_coords.tsv"),
site_column = "site",
x_column = "x",
y_column = "y",
color.point = "red",
radius.point = 5,
export.plot = F,
out.plot = "map_sites.html",
dirOut = paste0(system.file(package = "itineRis"), "/results/")){
if(!is.na(df.path)){
if(DescTools::SplitPath(df.path)$extension == "tsv"){sep = "\t"}
if(DescTools::SplitPath(df.path)$extension == "csv"){sep = ";"}
df <- read.table(df.path, sep = sep, header = T)
print(message(paste0("column names of '",
DescTools::SplitPath(df.path)$fullfilename,
"' are: ", paste0(colnames(df), collapse = ", "))))
} else {
df <- d[[d.coords]]
}
#lbl <- '<a href = "https://raw.githubusercontent.com/eamena-oxford/eamena-arches-dev/main/data/geojson/EAMENA-0164997.geojson">EAMENA-0164997.geojson</a>'
ea.map <- leaflet::leaflet() %>%
leaflet::addProviderTiles(leaflet::providers$"Esri.WorldImagery", group = "Ortho") %>%
leaflet::addProviderTiles(leaflet::providers$"OpenStreetMap", group = "OSM") %>%
leaflet::addCircleMarkers(
lng = as.numeric(df[, x_column]),
lat = as.numeric(df[, y_column]),
weight = 1,
radius = radius.point,
popup = df[, site_column],
color = color.point,
fillOpacity = 1,
opacity = 1) %>%
leaflet::addLayersControl(
baseGroups = c("Ortho", "OSM"),
position = "topright") %>%
leaflet::addScaleBar(position = "bottomright")
if (export.plot) {
dir.create(dirOut, showWarnings = FALSE)
htmlwidgets::saveWidget(ea.map, out.plot)
print(paste("interactive map '", out.plot, "' created in '", dirOut, "'"))
} else {
print(ea.map)
}
}
map_leaflet(d = d, d.coords = "mines.coords")
library(dplyt)
library(dplyr)
#' Create an HTML interactive map for the site distribution
#' @name map_leaflet
#' @description
#'
#' @param d a hash dictionnary-like object to store the data. By default NA
#' @param df.path the path to the dataframe. This dataframe must have at least three columns: one for the site name (by defaut 'site'), two for the coordinates (by default, 'x' and 'y'). By default NA, then will read the `d` variable
#' @param export.plot if TRUE, export the map
#' @param out.plot the name of the output map
#' @param dirOut path of the output directory
#'
#'
#' @return a leaflet interactive map
#'
#' @examples
#'
#' d <- hash::hash()
#' d <- read_mines(d = d,
#'                 df.path = "C:/Rprojects/itineRis/results/Coordinates-mines_Thomas Huet.xlsx")
#' map_leaflet(d = d, d.coords = "mines.coords")
#'
#'
#' map_leaflet(df.path = paste0(system.file(package = "itineRis"), "/extdata/sites_coords.tsv"),
#'             color.point = "blue")
#'
#' @export
map_leaflet <- function(d = NA,
d.coords = NA,
df.path = paste0(system.file(package = "itineRis"), "/extdata/sites_coords.tsv"),
site_column = "site",
x_column = "x",
y_column = "y",
color.point = "red",
radius.point = 5,
export.plot = F,
out.plot = "map_sites.html",
dirOut = paste0(system.file(package = "itineRis"), "/results/")){
if(!is.na(df.path)){
if(DescTools::SplitPath(df.path)$extension == "tsv"){sep = "\t"}
if(DescTools::SplitPath(df.path)$extension == "csv"){sep = ";"}
df <- read.table(df.path, sep = sep, header = T)
print(message(paste0("column names of '",
DescTools::SplitPath(df.path)$fullfilename,
"' are: ", paste0(colnames(df), collapse = ", "))))
} else {
df <- d[[d.coords]]
}
#lbl <- '<a href = "https://raw.githubusercontent.com/eamena-oxford/eamena-arches-dev/main/data/geojson/EAMENA-0164997.geojson">EAMENA-0164997.geojson</a>'
ea.map <- leaflet::leaflet() %>%
leaflet::addProviderTiles(leaflet::providers$"Esri.WorldImagery", group = "Ortho") %>%
leaflet::addProviderTiles(leaflet::providers$"OpenStreetMap", group = "OSM") %>%
leaflet::addCircleMarkers(
lng = as.numeric(df[, x_column]),
lat = as.numeric(df[, y_column]),
weight = 1,
radius = radius.point,
popup = df[, site_column],
color = color.point,
fillOpacity = 1,
opacity = 1) %>%
leaflet::addLayersControl(
baseGroups = c("Ortho", "OSM"),
position = "topright") %>%
leaflet::addScaleBar(position = "bottomright")
if (export.plot) {
dir.create(dirOut, showWarnings = FALSE)
htmlwidgets::saveWidget(ea.map, out.plot)
print(paste("interactive map '", out.plot, "' created in '", dirOut, "'"))
} else {
print(ea.map)
}
}
map_leaflet(d = d, d.coords = "mines.coords")
#' Create an HTML interactive map for the site distribution
#' @name map_leaflet
#' @description
#'
#' @param d a hash dictionnary-like object to store the data. By default NA
#' @param df.path the path to the dataframe. This dataframe must have at least three columns: one for the site name (by defaut 'site'), two for the coordinates (by default, 'x' and 'y'). By default NA, then will read the `d` variable
#' @param export.plot if TRUE, export the map
#' @param out.plot the name of the output map
#' @param dirOut path of the output directory
#'
#'
#' @return a leaflet interactive map
#'
#' @examples
#'
#' d <- hash::hash()
#' d <- read_mines(d = d,
#'                 df.path = "C:/Rprojects/itineRis/results/Coordinates-mines_Thomas Huet.xlsx")
#' map_leaflet(d = d, d.coords = "mines.coords")
#'
#'
#' map_leaflet(df.path = paste0(system.file(package = "itineRis"), "/extdata/sites_coords.tsv"),
#'             color.point = "blue")
#'
#' @export
map_leaflet <- function(d = NA,
d.coords = NA,
df.path = NA,
site_column = "site",
x_column = "x",
y_column = "y",
color.point = "red",
radius.point = 5,
export.plot = F,
out.plot = "map_sites.html",
dirOut = paste0(system.file(package = "itineRis"), "/results/")){
if(!is.na(df.path)){
if(DescTools::SplitPath(df.path)$extension == "tsv"){sep = "\t"}
if(DescTools::SplitPath(df.path)$extension == "csv"){sep = ";"}
df <- read.table(df.path, sep = sep, header = T)
print(message(paste0("column names of '",
DescTools::SplitPath(df.path)$fullfilename,
"' are: ", paste0(colnames(df), collapse = ", "))))
} else {
df <- d[[d.coords]]
}
#lbl <- '<a href = "https://raw.githubusercontent.com/eamena-oxford/eamena-arches-dev/main/data/geojson/EAMENA-0164997.geojson">EAMENA-0164997.geojson</a>'
ea.map <- leaflet::leaflet() %>%
leaflet::addProviderTiles(leaflet::providers$"Esri.WorldImagery", group = "Ortho") %>%
leaflet::addProviderTiles(leaflet::providers$"OpenStreetMap", group = "OSM") %>%
leaflet::addCircleMarkers(
lng = as.numeric(df[, x_column]),
lat = as.numeric(df[, y_column]),
weight = 1,
radius = radius.point,
popup = df[, site_column],
color = color.point,
fillOpacity = 1,
opacity = 1) %>%
leaflet::addLayersControl(
baseGroups = c("Ortho", "OSM"),
position = "topright") %>%
leaflet::addScaleBar(position = "bottomright")
if (export.plot) {
dir.create(dirOut, showWarnings = FALSE)
htmlwidgets::saveWidget(ea.map, out.plot)
print(paste("interactive map '", out.plot, "' created in '", dirOut, "'"))
} else {
print(ea.map)
}
}
map_leaflet(d = d, d.coords = "mines.coords")
map_leaflet(d = d, d.coords = "mines.coords", export.plot = T)
map_leaflet(d = d, d.coords = "mines.coords", export.plot = T)
dirOut
dirOut = paste0(system.file(package = "itineRis"), "/results/")
dirOut
#' Create an HTML interactive map for the site distribution
#' @name map_leaflet
#' @description
#'
#' @param d a hash dictionnary-like object to store the data. By default NA
#' @param df.path the path to the dataframe. This dataframe must have at least three columns: one for the site name (by defaut 'site'), two for the coordinates (by default, 'x' and 'y'). By default NA, then will read the `d` variable
#' @param export.plot if TRUE, export the map
#' @param out.plot the name of the output map
#' @param dirOut path of the output directory
#'
#'
#' @return a leaflet interactive map
#'
#' @examples
#'
#' d <- hash::hash()
#' d <- read_mines(d = d,
#'                 df.path = "C:/Rprojects/itineRis/results/Coordinates-mines_Thomas Huet.xlsx")
#' map_leaflet(d = d, d.coords = "mines.coords", export.plot = T)
#'
#'
#' map_leaflet(df.path = paste0(system.file(package = "itineRis"), "/extdata/sites_coords.tsv"),
#'             color.point = "blue")
#'
#' @export
map_leaflet <- function(d = NA,
d.coords = NA,
df.path = NA,
site_column = "site",
x_column = "x",
y_column = "y",
color.point = "red",
radius.point = 5,
export.plot = F,
out.plot = "map_sites.html",
dirOut = paste0(system.file(package = "itineRis"), "/results/")){
if(!is.na(df.path)){
if(DescTools::SplitPath(df.path)$extension == "tsv"){sep = "\t"}
if(DescTools::SplitPath(df.path)$extension == "csv"){sep = ";"}
df <- read.table(df.path, sep = sep, header = T)
print(message(paste0("column names of '",
DescTools::SplitPath(df.path)$fullfilename,
"' are: ", paste0(colnames(df), collapse = ", "))))
} else {
df <- d[[d.coords]]
}
#lbl <- '<a href = "https://raw.githubusercontent.com/eamena-oxford/eamena-arches-dev/main/data/geojson/EAMENA-0164997.geojson">EAMENA-0164997.geojson</a>'
ea.map <- leaflet::leaflet() %>%
leaflet::addProviderTiles(leaflet::providers$"Esri.WorldImagery", group = "Ortho") %>%
leaflet::addProviderTiles(leaflet::providers$"OpenStreetMap", group = "OSM") %>%
leaflet::addCircleMarkers(
lng = as.numeric(df[, x_column]),
lat = as.numeric(df[, y_column]),
weight = 1,
radius = radius.point,
popup = df[, site_column],
color = color.point,
fillOpacity = 1,
opacity = 1) %>%
leaflet::addLayersControl(
baseGroups = c("Ortho", "OSM"),
position = "topright") %>%
leaflet::addScaleBar(position = "bottomright")
if (export.plot) {
dir.create(dirOut, showWarnings = FALSE)
htmlwidgets::saveWidget(ea.map, out.plot)
print(paste0("interactive map '", out.plot, "' created in '", dirOut, "'"))
} else {
print(ea.map)
}
}
map_leaflet(d = d, d.coords = "mines.coords", export.plot = T)
df <- d[[d.coords]]
ea.map <- leaflet::leaflet() %>%
leaflet::addProviderTiles(leaflet::providers$"Esri.WorldImagery", group = "Ortho") %>%
leaflet::addProviderTiles(leaflet::providers$"OpenStreetMap", group = "OSM") %>%
leaflet::addCircleMarkers(
lng = as.numeric(df[, x_column]),
lat = as.numeric(df[, y_column]),
weight = 1,
radius = radius.point,
popup = df[, site_column],
color = color.point,
fillOpacity = 1,
opacity = 1) %>%
leaflet::addLayersControl(
baseGroups = c("Ortho", "OSM"),
position = "topright") %>%
leaflet::addScaleBar(position = "bottomright")
color.point = "red"
ea.map <- leaflet::leaflet() %>%
leaflet::addProviderTiles(leaflet::providers$"Esri.WorldImagery", group = "Ortho") %>%
leaflet::addProviderTiles(leaflet::providers$"OpenStreetMap", group = "OSM") %>%
leaflet::addCircleMarkers(
lng = as.numeric(df[, x_column]),
lat = as.numeric(df[, y_column]),
weight = 1,
radius = radius.point,
popup = df[, site_column],
color = color.point,
fillOpacity = 1,
opacity = 1) %>%
leaflet::addLayersControl(
baseGroups = c("Ortho", "OSM"),
position = "topright") %>%
leaflet::addScaleBar(position = "bottomright")
radius.point = 5
ea.map <- leaflet::leaflet() %>%
leaflet::addProviderTiles(leaflet::providers$"Esri.WorldImagery", group = "Ortho") %>%
leaflet::addProviderTiles(leaflet::providers$"OpenStreetMap", group = "OSM") %>%
leaflet::addCircleMarkers(
lng = as.numeric(df[, x_column]),
lat = as.numeric(df[, y_column]),
weight = 1,
radius = radius.point,
popup = df[, site_column],
color = color.point,
fillOpacity = 1,
opacity = 1) %>%
leaflet::addLayersControl(
baseGroups = c("Ortho", "OSM"),
position = "topright") %>%
leaflet::addScaleBar(position = "bottomright")
site_column = "site"
x_column = "x"
y_column = "y"
ea.map <- leaflet::leaflet() %>%
leaflet::addProviderTiles(leaflet::providers$"Esri.WorldImagery", group = "Ortho") %>%
leaflet::addProviderTiles(leaflet::providers$"OpenStreetMap", group = "OSM") %>%
leaflet::addCircleMarkers(
lng = as.numeric(df[, x_column]),
lat = as.numeric(df[, y_column]),
weight = 1,
radius = radius.point,
popup = df[, site_column],
color = color.point,
fillOpacity = 1,
opacity = 1) %>%
leaflet::addLayersControl(
baseGroups = c("Ortho", "OSM"),
position = "topright") %>%
leaflet::addScaleBar(position = "bottomright")
ea.map
htmlwidgets::saveWidget(ea.map, out.plot)
out.plot = "map_sites.html"
htmlwidgets::saveWidget(ea.map, out.plot)
out.plot
dirOut
path.out <- past0(dirOut, out.plot)
path.out <- paste0(dirOut, out.plot)
path.out
htmlwidgets::saveWidget(ea.map, path.out)
